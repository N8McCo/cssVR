<!DOCTYPE html>
<html lang="en">
<head>
  <title>css/vr test</title>
  <meta charset="utf-8">

  <script type="text/javascript">

function invertYAxis(q) {
  var x = q.x, y = q.y, z = q.z, w = q.w;
  x = x; y = -y; z = -z;
  var l = Math.sqrt(x*x + y*y + z*z + w*w);
  if (l == 0) {
    x = y = z = 0;
    w = 1;
  } else {
    l = 1/l;
    x *= l; y *= l; z *= l; w *= l;
  }
  return {
    x: x,
    y: y,
    z: z,
    w: w
  };

}

// helper function to convert a quaternion into a matrix, optionally
// inverting the quaternion along the way
function matrixFromOrientation(q, inverse) {
  var m = Array(16);

  var x = q.x, y = q.y, z = q.z, w = q.w;

  // if inverse is given, invert the quaternion first
  if (inverse) {
    x = -x; y = -y; z = -z;
    var l = Math.sqrt(x*x + y*y + z*z + w*w);
    if (l == 0) {
      x = y = z = 0;
      w = 1;
    } else {
      l = 1/l;
      x *= l; y *= l; z *= l; w *= l;
    }
  }

  var x2 = x + x, y2 = y + y, z2 = z + z;
  var xx = x * x2, xy = x * y2, xz = x * z2;
  var yy = y * y2, yz = y * z2, zz = z * z2;
  var wx = w * x2, wy = w * y2, wz = w * z2;

  m[0] = 1 - (yy + zz);
  m[4] = xy - wz;
  m[8] = xz + wy;

  m[1] = xy + wz;
  m[5] = 1 - (xx + zz);
  m[9] = yz - wx;

  m[2] = xz - wy;
  m[6] = yz + wx;
  m[10] = 1 - (xx + yy);

  m[3] = m[7] = m[11] = 0;
  m[12] = m[13] = m[14] = 0;
  m[15] = 1;

  return m;
}

function eulerFromQuaternion(q) {
  var pitch = Math.atan2(2.0*(q.y*q.z + q.w*q.x), q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z);
  var yaw = Math.asin(-2.0*(q.x*q.z - q.w*q.y));
  var roll = Math.atan2(2.0*(q.x*q.y + q.w*q.z), q.w*q.w + q.x*q.x - q.y*q.y - q.z*q.z);

  return {
    "yaw" : yaw * 180.0 / Math.PI,
    "pitch" : pitch * 180.0 / Math.PI,
    "roll" : roll * 180.0 / Math.PI
  };
};

function cssMatrixFromElements(e) {
  return "matrix3d(" + e.join(",") + ")";
}

function cssMatrixFromOrientation(q, inverse) {
  return cssMatrixFromElements(matrixFromOrientation(q, inverse));
}

// Our VR devices -- a HMD, and its associated orientation/position sensor
var vrHMD, vrSensor;

// the <div> element that we can make fullscreen
var cssContainer;

// the <div> element that will serve as our camera, moving the
// rest of the scene around
var cssCamera;

// the camera's position, as a css transform string.  For right now,
// we want it just in the middle.
// XXX BUG this rotateZ should not be needed; the view rendering is flipped.
// XXX BUG the rotateY should not be needed; the default viewport
// is not oriented how I expected it to be oriented
var cssCameraPositionTransform = "translate3d(0, 0, 0) rotateZ(180deg) rotateY(180deg)";


function normalizeQuaternion(q) {
  var l = Math.sqrt( q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w );

  if ( l === 0 ) {
    q.x = 0;
    q.y = 0;
    q.z = 0;
    q.w = 0;
  } else {
    l = 1 / l;
    q.x = q.x * l;
    q.y = q.y * l;
    q.z = q.z * l;
    q.w = q.w * l;
  }

  return q;
}

function multiplyQuaternions(q1, q2) {
  // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
  var q = {};
  q.x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
  q.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
  q.z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
  q.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;
  return q;
}

// a radians
// e.g: quaternionFromEuler(1, 0, 0, -15*PI/180)
function quaternionFromEuler(x, y, z, a){
    // Here we calculate the sin( theta / 2) once for optimization
    var result = Math.sin( (a) / 2.0 );
    var q = {
      'x': x * result,
      'y': y * result,
      'z': z * result,
      'w': Math.cos( a / 2.0 )
    };

    return normalizeQuaternion(q);
}

function frameCallback(e) {
  // This is needed to update the CSS orientation/position from the HMD's orientation/position.
  // In the future, we may have CSS transform function to do this automatically -- for example:
  //    transform: vrOrientation() vrPosition()
  // Where those would turn into full 4x4 matrices based on the current fullscreen HMD's orientation
  // and position.
  // XXX we should introduce quaternions to CSS as well

  window.requestAnimationFrame(frameCallback);

  var state = vrSensor.getState();
  var cssOrientationMatrix = cssMatrixFromOrientation(state.orientation, true);
  var transform = cssOrientationMatrix + " " + cssCameraPositionTransform;
  cssCamera.style.transform = transform;
  updateLaser(state.orientation);
}

function updateLaser(q) {
  var laserElement = document.querySelector('#laser');
  var cssOrientationMatrix = cssMatrixFromOrientation(invertYAxis(q));
  var cssLaserPositionTransform = 'translate3d(0, 0, 500px)';
  if (mouseCursorEnabled) {
    cssLaserPositionTransform = 'translate3d(0, 0, 500px) translate(' + cursorX + 'px, ' + cursorY + 'px)';
    //laserElement.style.left = cursorX + 'px';
    //laserElement.style.top = cursorY + 'px';
  }
  transform = cssOrientationMatrix + " " + cssLaserPositionTransform;
  laserElement.style.transform = transform;
  highlightStars();
}

var stars = [];

function highlightStars() {
  var laserElement = document.querySelector('#laser');
  var laserBox = laserElement.getBoundingClientRect();
  var starElement;
  var starBox;
  var star;
  for (i=0; i<stars.length; i++) {
    star = stars[i];
    star.el.classList.remove('highlighted');
    starBox = star.el.getBoundingClientRect();
    if (starBox.right < laserBox.left ||
        starBox.bottom < laserBox.top ||
        starBox.left > laserBox.right ||
        starBox.top > laserBox.bottom) {
      continue;
    }
    star.el.classList.add('highlighted');
  }
}

function vrDeviceCallback(vrdevs) {
  for (var i = 0; i < vrdevs.length; ++i) {
    if (vrdevs[i] instanceof HMDVRDevice) {
      vrHMD = vrdevs[i];
      break;
    }
  }

  if (!vrHMD)
    return;

  // Then, find that HMD's position sensor
  for (var i = 0; i < vrdevs.length; ++i) {
    if (vrdevs[i] instanceof PositionSensorVRDevice &&
        vrdevs[i].hardwareUnitId == vrHMD.hardwareUnitId)
    {
      vrSensor = vrdevs[i];
      break;
    }
  }

  if (!vrSensor) {
    alert("Found a HMD, but didn't find its orientation sensor?");
  }

  // kick off rendering
  requestAnimationFrame(frameCallback);
}

var mouseCursorEnabled = false;

function onkey(event) {
  switch (String.fromCharCode(event.charCode)) {
  case 'f':
    cssContainer.mozRequestFullScreen({ vrDisplay: vrHMD });
    break;
  case 'z':
    vrSensor.zeroSensor();
    break;
  case 'r':
    rotateSky();
    break;
  case 'm': // Enables/Disables mouse cursor
    if (!mouseCursorEnabled) {
      cssContainer.mozRequestPointerLock();
    } else {
      document.mozExitPointerLock();
    }
  }
}

var cursorX = 0;
var cursorY = 0;

function updateCursorCoordinates(e) {
  var movementX = e.movementX ||
      e.mozMovementX          ||
      e.webkitMovementX       ||
      0;

  var movementY = e.movementY ||
      e.mozMovementY          ||
      e.webkitMovementY       ||
      0;

  cursorX += movementX;
  cursorY += movementY;

  var minX = -cssContainer.clientWidth / 2;
  var maxX = cssContainer.clientWidth / 2;
  var minY = -cssContainer.clientHeight / 2;
  var maxY = cssContainer.clientHeight / 2;

  if(cursorX >= maxX - 300) {
    cursorX = maxX - 300;
  }

  if(cursorY >= maxY + 100) {
    cursorY = maxY + 100;
  }

  if(cursorX <= minX + 300) {
    cursorX = minX + 300;
  }

  if(cursorY <= minY - 100) {
    cursorY = minY - 100;
  }

}

// Hook pointer lock state change events for different browsers
document.addEventListener('pointerlockchange', lockChangeAlert, false);
document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);

function lockChangeAlert() {
  if(document.pointerLockElement === cssContainer ||
  document.mozPointerLockElement === cssContainer ||
  document.webkitPointerLockElement === cssContainer) {
    console.log('The pointer lock status is now locked');
    document.addEventListener("mousemove", updateCursorCoordinates, false);
    mouseCursorEnabled = true;
  } else {
    console.log('The pointer lock status is now unlocked');
    mouseCursorEnabled = false;
    document.removeEventListener("mousemove", updateCursorCoordinates, false);
  }
}

function init() {
  cssCamera = document.getElementById("camera");
  cssContainer = document.getElementById("container");

  if (navigator.getVRDevices)
    navigator.getVRDevices().then(vrDeviceCallback);
}

window.addEventListener("load", init, false);
window.addEventListener("keypress", onkey, true);

  </script>
</head>

<body>
  <style type="text/css">
/* keeping style block in body to make it easier to see the relationship between elements */

/* Container is nothing special; it's the element that is made full screen.
 * When non-fullscreen, you can add transforms to this element to make the scene
 * make sense in 2D (instead of being centered around the top left).  That transform
 * will cascade down to children when fullscreen though, so make sure to remove it when
 * entering fullscreen.  There's a -moz-full-screen selector that's useful for this.
 */
#container {
}

#container:not(:-moz-full-screen) {
  /* this is just to move the scene to the visible area when not in fullscreen VR */
  transform: translate(300px, 300px) rotateX(180deg);
  perspective: 1000px;
}


/* All threed-class elements have preserve-3d; preserve-3d is NOT inherited.  (There's an open
 * discussion on w3-style about adding a new transform-style that is like preserve-3d but is
 * inherited.)
 *
 * position: absolute; and 0,0 is also set because we'll position these elements fully using
 * 3D transforms.  Their CSS position is irrelevant for us.  Without this, their CSS position
 * will come into play as well as their transform.
 *
 * When in fullscreen VR, the 0,0,0 position is at the center of the viewport and not the top
 * left.
 *
 * We don't modify the original transform-origin here (50% 50% 0), because that can be useful
 * for moving elements around by their center point.  But it could also be set to 0,0,0 to
 * make it completely clear exactly where/how 3D objects are moving.
 */
.threed {
  transform-style: preserve-3d;
  position: absolute;
  top: 0; left: 0;
}

/* The camera div just serves as a way to set up a modelview transform for the entire rest of the
 * scene.  The transform that's set on it needs to be the *inverse* of where you want the camera
 * to be; that is, if you want the camera to be at (0, 0, 500), then the transform needs to be
 * set to (0, 0, -500).  The transform-origin is set here because we want to go from the origin
 */
#camera {
  transform-origin: 0 0 0;
  /* the transform itself is set programatically, since it needs to take into account the HMD orientation */
}

.star {
  width: 2px;
  height: 2px;
  background-color: white;
  border-radius: 50%
}

.highlighted .star-label{
  display: inline;
}

.star-label {
  display: none;
  color: white;
  font-size: 30px;
}

.polaris {
  width: 5px;
  height: 5px;
  transform: rotateY(0deg) rotateX(70deg) translate3d(0, 0, 500px) translate(-100px, -150px);
}

.polaris:after{
  margin-left: 20px;
  margin-top: 20px;
  content: "Polaris";
  font-size: 20px;
  color: white;
}

.moon {
  width: 60px;
  height: 60px;
  transform: rotateY(0deg) rotateX(30deg) translate3d(0, 0, 500px) translate(-100px, -150px);
  background-image: url('images/moon.png');
  background-size: contain;
}

#ground {
  background-color: brown;
  border-radius: 50%;
  width: 1000px; height: 1000px;
  background-color: rgb(38, 37, 13);
  background-image: url('images/grass.jpg');
  transform: translate(-500px, -500px) rotateX(90deg) translateZ(-200px);
}

#laser {
  width: 50px;
  height: 50px;
  background-color: transparent;
  border: 3px solid green;
  border-radius: 50%;
  transform: rotateY(0deg) rotateX(0deg) translate3d(0, 0, 500px) translate(-100px, -150px);
  z: 9999;
}

@keyframes rotate {
  from {
    transform: rotateY(0deg);
  }
  to {
    transform: rotateY(360deg);
  }
}

.rotateSky {
  animation: 15s rotate linear infinite;
}

  </style>

  <!-- this is a containing element that will be made fullscreen -->
  <div id="container" class="container">
    <!-- This is an inner element that will serve as a camera, moving its children around in the scene.
         This and all its children will have transform-style: preserve-3d set via the class, as well as
         transform-origin set to 0,0 -->
    <div id="camera" class="threed">
    <div id="laser" class="threed"></div>
    <div id="sky" class="threed">
    <div id="ground" class="threed"></div>
    </div>
  </div>
  <script type="text/javascript">

    var starColors = [
      "#8DA0E5",
      "#9BAFEA",
      "#BCCAEF",
      "#F6F5FD"
    ];

    function generateStars(numStars) {
      var skyElement = document.querySelector('#sky');
      var moonElement = document.createElement('div');
      var moonLabelElement = document.createElement('div');
      var polarisElement = document.createElement('div');

      for (i=0; i < numStars; ++i) {
        skyElement.appendChild(generateStar(i));
      }

      polarisElement.classList.add('threed');
      polarisElement.classList.add('star');
      polarisElement.classList.add('polaris');
      skyElement.appendChild(polarisElement);

      moonElement.classList.add('threed');
      moonElement.classList.add('moon');

      moonLabelElement.classList.add('star-label');
      moonLabelElement.classList.add('threed');
      moonLabelElement.textContent = 'Moon';
      moonElement.appendChild(moonLabelElement);
      stars.push({
        'el': moonElement,
        'ra': 0,
        'dec': 30
      });
      skyElement.appendChild(moonElement);

    }

    function generateStar(id) {
      var starElement = document.createElement('div');
      var starLabelElement = document.createElement('div');
      var ra = getRandomInt(0, 360);
      var dec = getRandomInt(-180, 180);
      var transform =
        'rotateY(' + ra +  'deg) ' +
        'rotateX(' + dec + 'deg) ' +
        'translate3d(0, 0, 500px) translate(-100px, -150px)';
      starElement.setAttribute('id', 'star-' + id);
      starElement.classList.add('star');
      starElement.classList.add('threed');
      starElement.style.transform = transform;
      starElement.style.backgroundColor = starColors[getRandomInt(0,3)];

      starLabelElement.classList.add('star-label');
      starLabelElement.classList.add('threed');
      starLabelElement.textContent = 'star ' + id;
      starElement.appendChild(starLabelElement);

      stars.push({
        "el": starElement,
        "ra": ra,
        "dec": dec
      });
      return starElement;
    }

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    function rotateSky() {
      var skyElement = document.querySelector('#sky');
      skyElement.classList.add('rotateSky');
    }

    generateStars(100);

  </script>
</body>
</html>
